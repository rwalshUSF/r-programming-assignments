{
  "hash": "cf98106f45b9f4f90a1715c551e139c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module # 5: Assignment: Matrix Algebra in R\"\nauthor: \"Robert Walsh\"\ndate: \"2025-09-22\"\n---\n\n\n\nThis is my Module #5 post for my LIS4370 blog. Welcome!\n\nCode repository:\n\n![](mod5.png)\n\n<https://github.com/rwalshUSF/RProgrammingFall2025WalshRobert/tree/main/assignments/assignment-05-doing-math-1>\n\nTask \\# 1 - Create matrices\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#In R, define\nA <- matrix(1:100, nrow = 10)\nB <- matrix(1:1000, nrow = 10)\n```\n:::\n\n\n\nTask \\# 2 - Inspect dimensions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Verify whether each matrix is square\ndim(A) # should be 10 x 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 10\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(B) # 10 x 100 - not square\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  10 100\n```\n\n\n:::\n:::\n\n\n\nTask \\# 3 - Compute inverse and determinant\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Use solve() and det(); handle errors for non-square or singular matrices:\n\n#For A\ninvA <- tryCatch(solve(A), error = function(e) print(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<simpleError in solve.default(A): Lapack routine dgesv: system is exactly singular: U[6,6] = 0>\n```\n\n\n:::\n\n```{.r .cell-code}\n# solve(A) does not work for my test! It produces an error!\n# Yes, the matrix is square, 10x10, however;\n# When I create matrix A, and use the solve() function the results produce\n# a calculation that states that Matrix A is exactly singular: U[6,6] = 0\n# This is perhaps due to strong correlations between the predictor variables:\ncor(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    1    1    1    1    1    1    1    1    1     1\n [2,]    1    1    1    1    1    1    1    1    1     1\n [3,]    1    1    1    1    1    1    1    1    1     1\n [4,]    1    1    1    1    1    1    1    1    1     1\n [5,]    1    1    1    1    1    1    1    1    1     1\n [6,]    1    1    1    1    1    1    1    1    1     1\n [7,]    1    1    1    1    1    1    1    1    1     1\n [8,]    1    1    1    1    1    1    1    1    1     1\n [9,]    1    1    1    1    1    1    1    1    1     1\n[10,]    1    1    1    1    1    1    1    1    1     1\n```\n\n\n:::\n\n```{.r .cell-code}\n# I wrapped solve(A) in a try-catch function to get the program to run.\n\ndetA <- det(A)\ndetA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\n# det(A) works, however, the output simply provides the 0 which indicates that\n# there is no inverse solution to this matrix, it is singular.\n\n#For B, use tryCatch to capture errors\ninvB <- tryCatch(solve(B), error = function(e) print(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<simpleError in solve.default(B): 'a' (10 x 100) must be square>\n```\n\n\n:::\n\n```{.r .cell-code}\n# The operations on B fail because the dimensions of matrix B are 10x100\n# resulting in a non-square matrix that does not have an inverse solution.\n\ndetB <- tryCatch(det(B), error = function(e) print(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<simpleError in determinant.matrix(x, logarithm = TRUE, ...): 'x' must be a square matrix>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Therefore solve(B) will not produce a solution and det(B) will not as well.\n```\n:::\n\n\n\nTask \\# 4 - Document your results\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# On your blog, include:\n\n# R code for creating A and B, and for computing invA, detA, invB, and detB\n# Shown Above.\n\n# Output or error messages for each operation.\n# Displayed after the erroneous function calls.\n\n# A brief explanation:\n\n# Why solve(A) and det(A) work.\n# Shown/explained above.\n\n# Any notes on numeric stability or performance.\n\n# Some notes on numeric stability include using randomized numbers that do\n# not match or correlate as closely. This will improve the performance of the\n# matrix linear algebra, and allow the functions/operations to compute\n# the correct results according to the proper matrix math, given that the\n# correct synax is provided in the code to perform the desired operations.\n# This can be considered when creating a linear model for bivariate and\n# multivariate linear regression and matrix math.\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}