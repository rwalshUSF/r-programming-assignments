{
  "hash": "ef215838088f63ffb0816747226c679d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module # 11: Debugging and Defensive Programming in R\"\nauthor: \"Robert Walsh\"\ndate: \"2025-11-03\"\n---\n\n\n\nModule 11 post for my LIS4370 blog. Welcome!\n\nCode repository:\n\n[![](mod11git.png)](mod11git.png)\n\n<https://github.com/rwalshUSF/RProgrammingFall2025WalshRobert/tree/main/assignments/assignment-11-%20Debugging>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Below is a function intended to flag rows of a numeric matrix x that are\n# outliers in every column according to the Tukey rule.\n# It contains a deliberate bug:\n\ntukey_multiple <- function(x) {\n  outliers <- array(TRUE, dim = dim(x))\n  for (j in 1:ncol(x)) {\n    outliers[, j] <- outliers[, j] && tukey.outlier(x[, j])\n  }\n  outlier.vec <- vector(\"logical\", length = nrow(x))\n  for (i in 1:nrow(x)) {\n    outlier.vec[i] <- all(outliers[i, ])\n  }\n  return(outlier.vec)\n}\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\nTask \\# 1 - Reproduce the Error\n\n------------------------------------------------------------------------\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# In R, create a test matrix and run the function:\nset.seed(123)\ntest_mat <- matrix(rnorm(50), nrow = 10)\n\n# Capture the exact error message you see.\n\ntryCatch({\n  # Code that might produce an error\n  tukey_multiple(test_mat)}, error = function(e) {\n\n    # Code to execute if an error occurs\n    message(\"An error occurred: \", e$message) # Print or capture the error message\n    return(NA) # Return a default value or handle the error as needed\n  })\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAn error occurred: 'length = 10' in coercion to 'logical(1)'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# Here is the error message:\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\nTask \\# 2 - Diagnose the Bug\n\n------------------------------------------------------------------------\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# traceback()\n# debug(tukey_multiple)\n# tukey_multiple(test_mat)\n\n# Here is the output from the debugging process:\n```\n:::\n\n\n\n[![](debug1.png)](debug1.png)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reflect on why using && inside the loop causes the failure.\n# (Recall that && only returns a single TRUE/FALSE for the first element,\n# whereas you need element‑wise comparison.)\n\n# The problem occurs with how element wise logical operators and logical operators\n# apply to operations with vectors.\n\n# '&' is vectorized and '&&' is not.\n\n# The '&&' is primarily designed for comparing single logical values ex. scalars. \n# When used with vectors like 'test_mat' or 'outliers' columns, it only considers \n# the first element of each vector for comparison and issues an error if the \n# vectors have more than one element. Whereas, the '&' operator performs a logical \n# 'AND' operation on each corresponding element of two vectors, resulting in a \n# new vector of logical values from evaluating both sides of the expression.\n\n# To fix this, we must change the '&&' in the code to '&' to analyze all elements \n# of each column of a matrix and/or each vector passed to the function.\n```\n:::\n\n\n\n[![](reflection.png)](reflection.png)\n\n------------------------------------------------------------------------\n\nTask \\# 3 - Fix the Code\n\n------------------------------------------------------------------------\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Edit the function so that the logical operation is applied element‑wise.\n# Specifically, replace the buggy line with the correct operator.\n\n# Corrected inside the loop:\n\n# outliers[, j] <- outliers[, j] & tukey.outlier(x[, j])\n\n#tukey_multiple <- function(x) {\n#  outliers <- array(TRUE, dim = dim(x))\n#  for (j in 1:ncol(x)) {\n#    outliers[, j] <- outliers[, j] & tukey.outlier(x[, j])\n#  }\n#  outlier.vec <- vector(\"logical\", length = nrow(x))\n#  for (i in 1:nrow(x)) {\n#    outlier.vec[i] <- all(outliers[i, ])\n#  }\n#  return(outlier.vec)\n#}\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\nTask \\# 4 - Validate Your Fix\n\n------------------------------------------------------------------------\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Re‑run your corrected function on test_mat and verify it returns a\n# logical vector of length 10 without error:\ncorrected_tukey <- function(x) {\n  outliers <- array(TRUE, dim = dim(x))\n  for (j in seq_len(ncol(x))) {\n    outliers[, j] <- outliers[, j] & tukey.outlier(x[, j])\n  }\n  outlier.vec <- logical(nrow(x))\n  for (i in seq_len(nrow(x))) {\n    outlier.vec[i] <- all(outliers[i, ])\n  }\n  outlier.vec\n}\n\ntryCatch({\n  # Code that might produce an error\n  corrected_tukey(test_mat)}, error = function(e) {\n\n    # Code to execute if an error occurs\n    message(\"An error occurred: \", e$message) # Print or capture the error message\n    return(NA) # Return a default value or handle the error as needed\n  })\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAn error occurred: could not find function \"tukey.outlier\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# Still producing error message - Diagnose the Bug\n# traceback()\n# debug(corrected_tukey)\n# corrected_tukey(test_mat)\n\n# Identify the faulty function & Fix the Code\n\n# Edit the function so that tukey.outlier() is removed.\ncorrected_tukey_multiple <- function(x) {\n  # Create array\n  outliers <- array(TRUE, dim = dim(x))\n  for (j in seq_len(ncol(x))) {\n    # Compare every element of array to x\n    outliers[, j] <- outliers[, j] & x[, j]\n  }\n  # Create vector for 'outliers' results\n  outlier.vec <- logical(nrow(x))\n  for (i in seq_len(nrow(x))) {\n    # Store results in vector\n    outlier.vec[i] <- all(outliers[i, ])\n  }\n  # Return results\n  outlier.vec\n}\n\n# Re‑run corrected function on test_mat and verify it returns a\n# logical vector of length 10 without error:\ntryCatch({\n  # Code that might produce an error\n  corrected_tukey_multiple(test_mat)}, error = function(e) {\n\n    # Code to execute if an error occurs\n    message(\"An error occurred: \", e$message) # Print or capture the error message\n    return(NA) # Return a default value or handle the error as needed\n  })\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n```\n\n\n:::\n:::\n\n\n\n[![](debug2.png)](debug2.png)\n\n------------------------------------------------------------------------\n\nTask \\# 5 - Defensive Enhancements (Optional)\n\n------------------------------------------------------------------------\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add checks at the top of your function to:\n# Ensure x is a numeric matrix.\n# Provide informative errors.\n\nenhanced_tukey_multiple <- function(x) {\n\n  # Ensure 'x' is a matrix\n  if (!is.matrix(x)) {\n    stop(\"Input 'x' must be a matrix.\")\n  }\n\n  # Ensure 'x' is numeric\n  if (!is.numeric(x)) {\n    # If the check fails, identify which columns are non-numeric\n    non_numeric_cols <- names(which(!apply(x, 2, is.numeric)))\n\n    if (length(non_numeric_cols) > 0) {\n      stop(paste0(\"All columns in 'x' must be numeric. Non-numeric columns found: \",\n                  paste(non_numeric_cols, collapse = \", \")))\n    } else {\n      # other non-numeric types\n      stop(\"Input 'x' must be a numeric matrix.\")\n    }\n  }\n\n  # Create array\n  outliers <- array(TRUE, dim = dim(x))\n  for (j in seq_len(ncol(x))) {\n    # Compare every element of array to x\n    outliers[, j] <- outliers[, j] & x[, j]\n  }\n  # Create vector for 'outliers' results\n  outlier.vec <- logical(nrow(x))\n  for (i in seq_len(nrow(x))) {\n    # Store results in vector\n    outlier.vec[i] <- all(outliers[i, ])\n  }\n  # Return results\n  outlier.vec\n}\n\n# Re‑run enhanced function on test_mat and verify it returns a\n# logical vector of length 10 without error:\ntryCatch({\n  # Code that might produce an error\n  enhanced_tukey_multiple(test_mat)}, error = function(e) {\n\n    # Code to execute if an error occurs\n    message(\"An error occurred: \", e$message) # Print or capture the error message\n    return(NA) # Return a default value or handle the error as needed\n  })\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# matrix test\ntryCatch({\n  # Code that might produce an error\n  enhanced_tukey_multiple(1)}, error = function(e) {\n\n    # Code to execute if an error occurs\n    message(\"An error occurred: \", e$message) # Print or capture the error message\n    return(NA) # Return a default value or handle the error as needed\n  })\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAn error occurred: Input 'x' must be a matrix.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# numeric test\ntryCatch({\n  # Code that might produce an error\n  enhanced_tukey_multiple(\"test one for numeric\")}, error = function(e) {\n\n    # Code to execute if an error occurs\n    message(\"An error occurred: \", e$message) # Print or capture the error message\n    return(NA) # Return a default value or handle the error as needed\n  })\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAn error occurred: Input 'x' must be a matrix.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}